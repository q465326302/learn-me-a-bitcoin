# 输出锁定
比特币批次的锁定机制。

## 什么是输出锁定？
输出锁是对输出设置的一组要求。必须满足这些要求才能在交易中使用输出。

例如，最常见的输出锁读取如下：
![Outputt%20Locks-1.png](img/Outputt%20Locks-1.png)

正是这些锁定机制防止我们在交易中花费彼此的输出，因为我们接收到的每个输出都被一个锁定机制所限制。

## 输出锁定来自哪里？
正如我们所知，交易是从现有的输出中创建新的输出的过程：
![Outputt%20Locks-2.png](img/Outputt%20Locks-2.png)

在创建这些输出时，我们为每个输出设置了“锁定”。
![Outputt%20Locks-3.png](img/Outputt%20Locks-3.png)

因此，当我们想要向朋友发送比特币时，我们创建新的输出，并添加一个锁定，该锁定表示“只有*1friend1234567890*的所有者可以使用此输出”。
![Outputt%20Locks-4.png](img/Outputt%20Locks-4.png)

>因此，这个新的输出实际上将“属于”我们的朋友，因为他们是唯一拥有此地址的私钥的人，所以没有其他人能够花费它.   
![Outputt%20Locks-5.png](img/Outputt%20Locks-5.png)
因此，尽管区块链是一系列交易的文件，但在实际应用中，您可以将其视为输出的存储单元。
![Outputt%20Locks-6.png](img/Outputt%20Locks-6.png)
当您想要将“您的”比特币发送给某人时，您只需引用区块链中您能够解锁的输出即可：
![Outputt%20Locks-7.png](img/Outputt%20Locks-7.png)
当这笔交易被记录在区块链中时，你使用的输出（作为输入）将无法再次使用。
![Outputt%20Locks-8.png](img/Outputt%20Locks-8.png)
因此，区块链存储了所有的输出，您可以随时使用其中任何一个输出。
当然，只要您能够解锁它们。

## 你如何创建输出锁定？
输出锁定是用一种基本的编程语言SCRIPT编写的。

在一个图表中解释整个编程语言的工作原理有点棘手，但我们还是来试着解释一下：
![Outputt%20Locks-9.png](img/Outputt%20Locks-9.png)

现在，这个锁定脚本最有趣的部分是**CHECKPRIVATEKEY**函数，我们使用它来设置锁的要求。

因此，对于这个特定的输出，我们设置了一个要求使用私钥与地址1EUXSxuUVy2PC5enGXR1a3yxbEjNWMHuem 进行比较的锁。

如果我们能提供这个锁所需的匹配私钥，我们就可以解锁它并在交易中使用它。

## 如何解锁输出锁定？
在构建交易数据时，每个您打算使用的输出后面都包括一个“解锁脚本”：
![Outputt%20Locks-10.png](img/Outputt%20Locks-10.png)

例如，要解锁典型的锁定脚本（例如[地址][CHECKPRIVATEKEY]），我们需要证明我们拥有地址[地址]。为此，我们使用私钥创建数字签名。
![Outputt%20Locks-11.png](img/Outputt%20Locks-11.png)

当节点接收到这个交易数据时，它们将运行“锁定”+“解锁”脚本，以查看您的数字签名是否与输出所锁定的地址相匹配。
![Outputt%20Locks-12.png](img/Outputt%20Locks-12.png)

如果一切顺利，节点会接受交易并将其传递给其他节点，每个节点在接受交易之前都会运行“锁定”+“解锁”脚本。

这就是如何解锁输出锁定。

## 什么鬼？我们正在泄露我们的私钥！

敏锐的观察，先生。

>**坦白说：我们并不直接将私钥放入交易数据中。**

你看，为了避免在交易数据中泄露私钥，我们创建了一种叫做“数字签名”的东西：
![Outputt%20Locks-13.png](img/Outputt%20Locks-13.png)

显然，我说谎了关于我们使用的那个函数。但是不用担心，实际上有一个比较[地址]和[数字签名]的函数，它被称为CHECKSIG。
![Outputt%20Locks-14.png](img/Outputt%20Locks-14.png)

由于数字签名和CHECKSIG功能的神奇作用，我们仍然可以将输出锁定到地址，并能够在不泄露私钥的情况下解锁它们。

非常棒。